{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"\ud83c\udfae Python for Control Systems","text":"<p>Welcome to Python4Control - your comprehensive guide to mastering control systems with Python! \ud83d\ude80</p>"},{"location":"index.html#overview","title":"Overview","text":"<p>This documentation provides a structured approach to learning control systems using Python, perfect for students, engineers, and hobbyists. Our tutorials combine theoretical concepts with practical implementations, making complex control theory accessible and applicable.</p>"},{"location":"index.html#available-tutorials","title":"\ud83d\udcda Available Tutorials","text":"<ul> <li> <p> Introduction to Control Systems</p> <p>Learn the fundamentals of control systems and Python implementation.</p> <p> Go to tutorial</p> </li> <li> <p> System Responses</p> <p>Learn about time and frequency domain responses of control systems.</p> <p> Go to tutorial</p> </li> <li> <p> Root Locus Analysis</p> <p>Master root locus techniques for control system analysis and design.</p> <p> Go to tutorial</p> </li> <li> <p> Bode Plot Analysis</p> <p>Learn frequency response analysis using Bode plots.</p> <p> Go to tutorial</p> </li> </ul>"},{"location":"index.html#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li> <p> System Analysis</p> <ul> <li>Transfer function manipulation</li> <li>State-space representations</li> <li>System response analysis</li> </ul> </li> <li> <p> Controller Design</p> <ul> <li>PID controller tuning</li> <li>State feedback control</li> <li>Observer design</li> </ul> </li> <li> <p> Visualization</p> <ul> <li>Time-domain responses</li> <li>Frequency responses</li> <li>Root locus plots</li> </ul> </li> <li> <p> Applications</p> <ul> <li>Real-world examples</li> <li>Practical implementations</li> <li>Case studies</li> </ul> </li> </ul>"},{"location":"index.html#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li> <p> Installation</p> <pre><code>git clone https://github.com/Hmustf/python4control.git\ncd python4control\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre> </li> <li> <p> Prerequisites</p> <ul> <li>Python 3.8+</li> <li>Basic control theory knowledge</li> <li>Familiarity with Python programming</li> </ul> </li> </ul>"},{"location":"index.html#useful-resources","title":"\ud83d\udd17 Useful Resources","text":"<ul> <li> <p> Libraries</p> <ul> <li>Python Control Systems Library</li> <li>NumPy Documentation</li> <li>Matplotlib Documentation</li> </ul> </li> <li> <p> Support</p> <ul> <li>GitHub Repository</li> <li>Report Issues</li> <li>Contributing Guidelines</li> </ul> </li> </ul>"},{"location":"index.html#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Whether it's adding new tutorials, improving existing examples, fixing bugs, or enhancing documentation, your help is appreciated. Check our Contributing Guidelines to get started. </p>"},{"location":"control-design/01_intro.html","title":"Control System Design with Python","text":""},{"location":"control-design/01_intro.html#introduction-to-python-for-control-systems","title":"Introduction to Python for Control Systems","text":"<p>Python is a versatile programming language that's excellent for control systems engineering. We'll use several key libraries: - <code>numpy</code> for numerical computations - <code>control</code> for control systems analysis - <code>matplotlib</code> for plotting</p>"},{"location":"control-design/01_intro.html#basic-python-concepts","title":"Basic Python Concepts","text":"<p>Python's syntax is clean and readable. Here are some basic examples:</p> <p><pre><code># Basic variable assignments\nx = 123.3\ntext = \"Some text\"\nflag = True\nprint(f\"x = {x}, text = {text}, flag = {flag}\")\n\n# Lists (similar to arrays in other languages)\nx = [1, 2, 3, 4]\nprint(\"List x:\", x)\n\n# Using NumPy for numerical arrays\nimport numpy as np\nx = np.array([1, 2, 3, 4])\nprint(\"NumPy array x:\", x)\n\n# Creating arrays of zeros and ones\nx = np.zeros(4)\ny = np.ones((2, 2))\nprint(\"Array of zeros:\", x)\nprint(\"2x2 array of ones:\\n\", y)\n</code></pre> <pre><code>Output:\nx = 123.3, text = Some text, flag = True\nList x: [1, 2, 3, 4]\nNumPy array x: [1 2 3 4]\nArray of zeros: [0. 0. 0. 0.]\n2x2 array of ones:\n [[1. 1.]\n  [1. 1.]]\n</code></pre></p>"},{"location":"control-design/01_intro.html#functions-in-python","title":"Functions in Python","text":"<p>Functions are defined using the <code>def</code> keyword:</p> <p><pre><code>def square(x):\n    return x * x\n\nx = 2\ny = square(x)\nprint(f\"The square of {x} is {y}\")\n\n# Let's try with a list of numbers\nnumbers = [1, 2, 3, 4]\nsquares = [square(n) for n in numbers]\nprint(f\"The squares of {numbers} are {squares}\")\n</code></pre> <pre><code>Output:\nThe square of 2 is 4\nThe squares of [1, 2, 3, 4] are [1, 4, 9, 16]\n</code></pre></p>"},{"location":"control-design/01_intro.html#control-systems-with-python-control","title":"Control Systems with Python Control","text":"<p>The <code>control</code> library provides powerful tools for control systems analysis. Let's look at some basic examples:</p>"},{"location":"control-design/01_intro.html#single-step-response","title":"Single Step Response","text":"<p>Here's how to create a transfer function and plot its step response:</p> <p><pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a transfer function G(s) = (s + 2)/(s^2 + 2s + 1)\ns = control.TransferFunction.s\nG = control.TransferFunction([1, 2], [1, 2, 1])\n\n# Print transfer function\nprint(\"Transfer function G(s):\")\nprint(G)\n\n# Generate and plot step response\nt, y = control.step_response(G)\nplt.figure()  # Using default size\nplt.plot(t, y, linewidth=2)\nplt.grid(True)\nplt.title('Step Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre> <pre><code>Output:\nTransfer function G(s):\n       s + 2\n-------------------\ns^2 + 2 s + 1\n</code></pre></p> <p> </p>"},{"location":"control-design/01_intro.html#multiple-step-responses","title":"Multiple Step Responses","text":"<p>We can also compare step responses of different systems:</p> <p><pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create figure\nplt.figure()  # Using default size\nt = np.linspace(0, 5, 500)\n\n# Generate step responses for different systems\nfor a in range(1, 6):\n    # Create transfer function G(s) = a/(s + a)\n    G = control.TransferFunction([a], [1, a])\n    print(f\"\\nTransfer function for a={a}:\")\n    print(G)\n\n    # Get and plot step response\n    t, y = control.step_response(G, t)\n    plt.plot(t, y, linewidth=2, label=f'a={a}')\n\nplt.grid(True)\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.title('Step Responses for Different Systems')\nplt.legend(loc='lower right')\nplt.show()\n</code></pre> <pre><code>Output:\nTransfer function for a=1:\n  1\n-----\ns + 1\n\nTransfer function for a=2:\n  2\n-----\ns + 2\n\nTransfer function for a=3:\n  3\n-----\ns + 3\n\nTransfer function for a=4:\n  4\n-----\ns + 4\n\nTransfer function for a=5:\n  5\n-----\ns + 5\n</code></pre></p> <p> </p> <p>This example shows how to: 1. Create transfer functions with different parameters 2. Generate step responses 3. Plot multiple responses on the same graph 4. Add proper labels and legends</p> <p>The Python ecosystem provides these powerful tools for control systems analysis, making it an excellent choice for control system design and analysis.</p>"},{"location":"control-design/02_system_responses.html","title":"System Responses in Control Systems","text":"<p>This tutorial covers the analysis of system responses in both time and frequency domains.</p>"},{"location":"control-design/02_system_responses.html#time-domain-responses","title":"Time Domain Responses","text":""},{"location":"control-design/02_system_responses.html#step-response","title":"Step Response","text":"<p>The step response is one of the most fundamental ways to analyze a control system's behavior.</p> <pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a transfer function G(s) = 1/(s + 1)\nG = control.TransferFunction([1], [1, 1])\n\n# Generate step response\nt, y = control.step_response(G)\n\nplt.figure()\nplt.plot(t, y)\nplt.grid(True)\nplt.title('Step Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(s + 1)\nFinal Value: 1.00\nRise Time: 2.30 seconds\nSettling Time: 3.91 seconds\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#impulse-response","title":"Impulse Response","text":"<p>The impulse response shows how the system responds to a brief input pulse.</p> <pre><code># Generate impulse response\nt, y = control.impulse_response(G)\n\nplt.figure()\nplt.plot(t, y)\nplt.grid(True)\nplt.title('Impulse Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(s + 1)\nPeak Value: 1.00\nPeak Time: 0.00 seconds\nSettling Time: 3.98 seconds\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#ramp-response","title":"Ramp Response","text":"<p>The ramp response shows how the system follows a continuously increasing input.</p> <pre><code># Create time vector\nt = np.linspace(0, 10, 1000)\nu = t\nt_out, y = control.forced_response(G, T=t, U=u)\n\nplt.figure()\nplt.plot(t_out, u, '--', label='Input')\nplt.plot(t_out, y, label='Output')\nplt.grid(True)\nplt.title('Ramp Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(s + 1)\nSteady-State Error Rate: 1.00\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#response-characteristics","title":"Response Characteristics","text":""},{"location":"control-design/02_system_responses.html#rise-time","title":"Rise Time","text":"<p>The time required for the system output to rise from 10% to 90% of its final value. - In our example: 2.30 seconds</p>"},{"location":"control-design/02_system_responses.html#settling-time","title":"Settling Time","text":"<p>The time required for the system to settle within \u00b12% of its final value. - For our first-order system: 3.91 seconds (approximately 4 time constants)</p>"},{"location":"control-design/02_system_responses.html#overshoot","title":"Overshoot","text":"<p>The maximum peak value of the response curve measured from the desired response of the system. - Our first-order system has no overshoot</p>"},{"location":"control-design/02_system_responses.html#steady-state-error","title":"Steady-State Error","text":"<p>The difference between the desired output and the actual output as time approaches infinity. - In our step response example: 0 (Final value = 1.00) - In our ramp response example: Constant error rate of 1.00</p>"},{"location":"control-design/02_system_responses.html#example-analyzing-second-order-system","title":"Example: Analyzing Second-Order System","text":"<pre><code>import matplotlib.pyplot as plt\nimport control\nimport numpy as np\nimport seaborn as sns\n\n# Set the style to a modern, clean theme\nplt.style.use('seaborn-v0_8')\nsns.set_style(\"whitegrid\", {'grid.linestyle': ':'})\nplt.rcParams['font.family'] = 'sans-serif'\nplt.rcParams['font.sans-serif'] = ['Arial']\n\n# Define system parameters\nNATURAL_FREQUENCY = 1.0  # Natural frequency (wn)\nDAMPING_RATIO = 0.5      # Damping ratio (zeta)\n\n# Create a second-order transfer function\nnumerator = [NATURAL_FREQUENCY**2]\ndenominator = [1, 2 * DAMPING_RATIO * NATURAL_FREQUENCY, NATURAL_FREQUENCY**2]\nG = control.TransferFunction(numerator, denominator)\n\n# Get step response\nt, y = control.step_response(G)\n\n# Get step response characteristics\ninfo = control.step_info(G)\n\n# Extract key values\nrise_time = info['RiseTime']\npeak_time = info['PeakTime']\npeak_value = info['Peak']\nsettling_time = info['SettlingTime']\novershoot = info['Overshoot']\n\n# Function to find the nearest index in the time array\ndef find_nearest(array, value):\n    idx = (np.abs(array - value)).argmin()\n    return idx\n\n# Create figure with a specific background color\nplt.figure(figsize=(14, 8))\nax = plt.gca()\nax.set_facecolor('#ffffff')\nplt.gcf().set_facecolor('#ffffff')\n\n# Custom color palette\nmain_color = '#2E86AB'  # Blue\nsteady_state_color = '#D64933'  # Red\nannotation_color = '#1B1B1E'  # Dark gray\ngrid_color = '#E5E5E5'  # Light gray\novershoot_color = '#FF6B6B'  # Coral for overshoot arrow\nsettling_color = '#6C757D'  # Gray for settling bounds\n\n# Plot step response curve with gradient\nline, = plt.plot(t, y, label='Step Response', linewidth=3, color=main_color)\n\n# Plot steady-state line\nplt.axhline(y=1, color=steady_state_color, linestyle='--', label='Steady-State Value', linewidth=2, alpha=0.8)\n\n# Add \u00b12% settling time bounds\nplt.axhline(y=1.02, color=settling_color, linestyle=':', label='\u00b12% Bounds', linewidth=1.5, alpha=0.6)\nplt.axhline(y=0.98, color=settling_color, linestyle=':', linewidth=1.5, alpha=0.6)\n\n# Create shaded regions for better visualization\nplt.fill_between(t, y, 1, where=(y &gt; 1), color=main_color, alpha=0.15, interpolate=True, label='Error')\nplt.fill_between(t, y, 1, where=(y &lt; 1), color=main_color, alpha=0.1, interpolate=True)\n\n# Plot vertical lines with gradient alpha\nfor time, label in [(rise_time, 'Rise Time'), (peak_time, 'Peak Time'), (settling_time, 'Settling Time')]:\n    plt.vlines(time, 0, y[find_nearest(t, time)], colors=annotation_color, linestyles=':', alpha=0.3)\n\n# Create fancy boxes for annotations with improved styling\ndef create_annotation_box(text):\n    return dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.95, \n               edgecolor=annotation_color, linewidth=1)\n\n# Add overshoot double-headed arrow\nplt.annotate('', xy=(peak_time, peak_value), \n            xytext=(peak_time, 1),\n            arrowprops=dict(arrowstyle='&lt;-&gt;', color=overshoot_color, \n                          linewidth=2, shrinkA=0, shrinkB=0))\n\n# Add overshoot label centered on the double-headed arrow\nplt.annotate(f'Overshoot\\n{overshoot:.1f}%', \n            xy=(peak_time, (peak_value + 1)/2),  # Middle point of the arrow\n            xytext=(peak_time, (peak_value + 1)/2),  # Exactly on the arrow\n            fontsize=9,\n            color=annotation_color,\n            bbox=create_annotation_box(''),\n            ha='center',  # Center horizontally\n            va='center')  # Center vertically\n\nplt.annotate(f'Rise Time\\n{rise_time:.2f} s', \n             xy=(rise_time, y[find_nearest(t, rise_time)]),\n             xytext=(rise_time + 1, y[find_nearest(t, rise_time)] - 0.2),\n             fontsize=11,\n             color=annotation_color,\n             bbox=create_annotation_box(''),\n             arrowprops=dict(arrowstyle='fancy', color=annotation_color, alpha=0.6),\n             ha='center')\n\nplt.annotate(f'Peak Time\\n{peak_time:.2f} s', \n             xy=(peak_time, peak_value),\n             xytext=(peak_time + 0.5, peak_value + 0.1),\n             fontsize=11,\n             color=annotation_color,\n             bbox=create_annotation_box(''),\n             arrowprops=dict(arrowstyle='fancy', color=annotation_color, alpha=0.6),\n             ha='center')\n\n# Add settling time annotation with bounds info\nplt.annotate(f'Settling Time\\n{settling_time:.2f} s\\n\u00b12% Bounds', \n             xy=(settling_time, 1),\n             xytext=(settling_time + 1.5, 1.1),  # Changed y position from 0.7 to 0.8\n             fontsize=11,\n             color=annotation_color,\n             bbox=create_annotation_box(''),\n             arrowprops=dict(arrowstyle='fancy', color=annotation_color, alpha=0.6),\n             ha='center')\n\n# Add system parameters annotation\nplt.text(0.02, 0.98, f'System Parameters:\\n\u03c9n = {NATURAL_FREQUENCY} rad/s\\n\u03b6 = {DAMPING_RATIO}',\n         transform=ax.transAxes,\n         bbox=dict(facecolor='white', alpha=0.95, edgecolor=annotation_color, \n                  boxstyle='round,pad=0.5', linewidth=1),\n         fontsize=11,\n         color=annotation_color,\n         verticalalignment='top')\n\n# Enhance grid with custom styling\nax.grid(True, which='major', color=grid_color, linewidth=1.2, alpha=0.8)\nax.grid(True, which='minor', color=grid_color, linewidth=0.8, alpha=0.5)\n\n# Set axis limits with padding to ensure annotations are visible\nplt.xlim(-0.2, max(t) + 0.5)\nplt.ylim(-0.1, max(y) + 0.3)\n\n# Title and labels with enhanced styling\nplt.title('Second-Order System Step Response', fontsize=16, pad=20, \n          color=annotation_color, fontweight='bold')\nplt.xlabel('Time (s)', fontsize=12, labelpad=10, color=annotation_color)\nplt.ylabel('Amplitude', fontsize=12, labelpad=10, color=annotation_color)\n\n# Customize ticks\nplt.xticks(fontsize=10, color=annotation_color)\nplt.yticks(fontsize=10, color=annotation_color)\n\n# Enhanced legend with new styling\nplt.legend(loc='upper right', fontsize=11, fancybox=True, \n          framealpha=0.95, edgecolor=annotation_color)\n\n# Adjust layout and save with high DPI\nplt.tight_layout()\nplt.savefig('docs/images/examples/second_order_response.png', dpi=300, bbox_inches='tight', \n            facecolor='white', edgecolor='none')\n\n# Show plot\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = \u03c9n\u00b2/(s\u00b2 + 2\u03b6\u03c9n\u00b7s + \u03c9n\u00b2)\nNatural Frequency (\u03c9n): 1.00 rad/s\nDamping Ratio (\u03b6): 0.50\nRise Time: 1.67 seconds\nPeak Time: 3.63 seconds\nOvershoot: 16.3%\nSettling Time: 8.09 seconds\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#exercises","title":"Exercises","text":"<ol> <li>Create a transfer function for a second-order system with different natural frequencies and damping ratios. Compare their step responses.</li> <li>Analyze how the damping ratio affects the overshoot and settling time of a second-order system.</li> <li>Design a system to meet specific time-domain specifications (rise time, settling time, overshoot).</li> </ol>"},{"location":"control-design/03_root_locus.html","title":"Root Locus Analysis","text":"<p>The root locus is a graphical method for analyzing how the poles of a closed-loop system change as a system parameter (usually the gain) varies.</p>"},{"location":"control-design/03_root_locus.html#understanding-root-locus","title":"Understanding Root Locus","text":"<p>The root locus shows the paths that the poles of the closed-loop system follow as the gain K varies from 0 to \u221e. For a system with forward transfer function G(s) and unity feedback:</p> \\[ T(s) = \\frac{KG(s)}{1 + KG(s)} \\]"},{"location":"control-design/03_root_locus.html#basic-rules-for-sketching-root-locus","title":"Basic Rules for Sketching Root Locus","text":"<ol> <li>The root locus starts at the open-loop poles (K = 0)</li> <li>The root locus ends at the open-loop zeros (K = \u221e)</li> <li>The number of branches equals the number of open-loop poles</li> <li>Branches approach asymptotes at high gains</li> <li>The root locus is symmetric about the real axis</li> </ol>"},{"location":"control-design/03_root_locus.html#example-1-simple-second-order-system","title":"Example 1: Simple Second-Order System","text":"<pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create transfer function G(s) = 1/(s(s + 2))\nnum = [1]\nden = [1, 2, 0]  # s^2 + 2s\nG = control.TransferFunction(num, den)\n\n# Generate root locus\nplt.figure(figsize=(10, 8))\nrlist, klist = control.root_locus(G, plot=True)\nplt.title('Root Locus: G(s) = 1/s(s + 2)')\nplt.grid(True)\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/s(s + 2)\nOpen-Loop Poles: [-2.+0.j  0.+0.j]\nCritical Gain (K) at Imaginary Axis: 0.00\n</code></pre></p> <p></p>"},{"location":"control-design/03_root_locus.html#example-2-system-with-multiple-poles","title":"Example 2: System with Multiple Poles","text":"<pre><code># Create transfer function G(s) = 1/((s+1)(s+2)(s+3))\nG = control.TransferFunction([1], [1, 6, 11, 6])\n\n# Generate root locus\nplt.figure(figsize=(10, 8))\nrlist, klist = control.root_locus(G, plot=True)\nplt.title('Root Locus: G(s) = 1/((s+1)(s+2)(s+3))')\nplt.grid(True)\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/((s+1)(s+2)(s+3))\nOpen-Loop Poles: [-3.+0.j -2.+0.j -1.+0.j]\n</code></pre></p> <p></p>"},{"location":"control-design/03_root_locus.html#analyzing-root-locus-features","title":"Analyzing Root Locus Features","text":""},{"location":"control-design/03_root_locus.html#break-away-points","title":"Break-Away Points","text":"<p>Points where branches of the root locus depart from the real axis.</p> <p>For our simple second-order system: - Break-away point occurs at s = -1 (where the branches split from the real axis) - This happens at a gain value of K = 1</p>"},{"location":"control-design/03_root_locus.html#crossing-points","title":"Crossing Points","text":"<p>Points where the root locus crosses the imaginary axis, indicating stability boundaries.</p> <p>For our simple second-order system: - The root locus crosses the imaginary axis at approximately \u00b1j1.4 - This occurs at a gain value of K \u2248 4.0</p>"},{"location":"control-design/03_root_locus.html#design-example-lead-compensator","title":"Design Example: Lead Compensator","text":"<pre><code># Design a lead compensator\nalpha = 10\nT = 1\nnum_c = [T, 1]\nden_c = [T/alpha, 1]\nC = control.TransferFunction(num_c, den_c)\n\n# Combined system\nGC = control.series(G, C)\n\n# Plot root locus of compensated system\nplt.figure(figsize=(10, 8))\ncontrol.root_locus(GC)\nplt.title('Root Locus with Lead Compensator')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"control-design/03_root_locus.html#stability-analysis-using-root-locus","title":"Stability Analysis Using Root Locus","text":""},{"location":"control-design/03_root_locus.html#gain-selection","title":"Gain Selection","text":"<p>The root locus helps in selecting appropriate gain values for stability:</p> <pre><code># Find gain for specific closed-loop poles\ndesired_poles = [-1 + 1j, -1 - 1j]\nK = control.root_locus_plot(G, plot=False)\n</code></pre>"},{"location":"control-design/03_root_locus.html#stability-margins","title":"Stability Margins","text":"<p>Analyzing stability margins from root locus:</p> <pre><code># Calculate gain and phase margins\ngm, pm, _, _ = control.margin(G)\nprint(f\"Gain Margin: {gm} dB\")\nprint(f\"Phase Margin: {pm} degrees\")\n</code></pre>"},{"location":"control-design/03_root_locus.html#exercises","title":"Exercises","text":"<ol> <li>Plot the root locus for a system with transfer function G(s) = K/(s\u00b2 + 2s + 2).</li> <li>Find the range of K for which the system is stable.</li> <li>Design a compensator to achieve specific closed-loop pole locations.</li> <li>Analyze how zeros affect the root locus shape and system stability.</li> </ol>"},{"location":"control-design/04_bode_plot.html","title":"Bode Plot Analysis","text":"<p>Bode plots are frequency response diagrams that show the magnitude and phase of a system's frequency response on separate logarithmic plots.</p>"},{"location":"control-design/04_bode_plot.html#understanding-bode-plots","title":"Understanding Bode Plots","text":"<p>A Bode plot consists of two graphs: 1. Magnitude plot (in decibels) vs. frequency 2. Phase plot (in degrees) vs. frequency</p>"},{"location":"control-design/04_bode_plot.html#basic-elements-of-bode-plots","title":"Basic Elements of Bode Plots","text":""},{"location":"control-design/04_bode_plot.html#first-order-systems","title":"First-Order Systems","text":"<p>For a first-order system G(s) = 1/(\u03c4s + 1):</p> <pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create first-order system\ntau = 1.0  # Time constant\nG = control.TransferFunction([1], [tau, 1])\n\n# Generate Bode plot\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, dB=True)\nplt.suptitle('Bode Plot: First-Order System')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(\u03c4s + 1)\nTime Constant (\u03c4): 1.00\nCorner Frequency: 1.00 rad/s\nPhase at Corner Frequency: -0.8 degrees\n</code></pre></p> <p></p>"},{"location":"control-design/04_bode_plot.html#second-order-systems","title":"Second-Order Systems","text":"<p>For a second-order system G(s) = \u03c9n\u00b2/(s\u00b2 + 2\u03b6\u03c9n\u00b7s + \u03c9n\u00b2):</p> <pre><code># Create second-order system\nwn = 10.0  # Natural frequency\nzeta = 0.5  # Damping ratio\nnum = [wn**2]\nden = [1, 2*zeta*wn, wn**2]\nG = control.TransferFunction(num, den)\n\n# Generate Bode plot\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, dB=True)\nplt.suptitle('Bode Plot: Second-Order System')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = \u03c9n\u00b2/(s\u00b2 + 2\u03b6\u03c9n\u00b7s + \u03c9n\u00b2)\nNatural Frequency (\u03c9n): 10.00 rad/s\nDamping Ratio (\u03b6): 0.50\nResonance Peak: 1.15 dB\nResonance Frequency: 7.06 rad/s\n</code></pre></p> <p></p>"},{"location":"control-design/04_bode_plot.html#frequency-response-analysis","title":"Frequency Response Analysis","text":""},{"location":"control-design/04_bode_plot.html#bandwidth","title":"Bandwidth","text":"<p>The frequency at which the magnitude drops by -3dB:</p> <pre><code># Function to find bandwidth\ndef find_bandwidth(sys):\n    w = np.logspace(-2, 2, 1000)\n    mag, _, _ = control.bode(sys, w, plot=False)\n\n    # Find -3dB frequency\n    bandwidth_idx = np.where(mag &lt;= -3)[0][0]\n    return w[bandwidth_idx]\n</code></pre> <p>For our second-order system: - Bandwidth \u2248 10 rad/s (at the natural frequency) - The -3dB point occurs at approximately the natural frequency</p>"},{"location":"control-design/04_bode_plot.html#resonance-peak","title":"Resonance Peak","text":"<p>The maximum magnitude in the frequency response:</p> <pre><code># Function to find resonance peak\ndef find_resonance(sys):\n    w = np.logspace(-2, 2, 1000)\n    mag, _, _ = control.bode(sys, w, plot=False)\n\n    return np.max(mag), w[np.argmax(mag)]\n</code></pre> <p>For our second-order system with \u03b6 = 0.5: - Resonance Peak: 1.15 dB - Resonance Frequency: 7.06 rad/s</p>"},{"location":"control-design/04_bode_plot.html#example-band-pass-filter","title":"Example: Band-Pass Filter","text":"<pre><code># Define band-pass filter parameters\nf0 = 100  # Center frequency (Hz)\nQ = 10    # Quality factor\nw0 = 2 * np.pi * f0\n\n# Create transfer function\nnum = [w0/Q, 0]\nden = [1, w0/Q, w0**2]\nG = control.TransferFunction(num, den)\n\n# Generate Bode plot\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, dB=True)\nplt.suptitle('Bode Plot: Band-Pass Filter')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = (w0/Q\u00b7s)/(s\u00b2 + (w0/Q)s + w0\u00b2)\nCenter Frequency (f0): 100.00 Hz\nQuality Factor (Q): 10.00\nGain Margin: inf dB at nan rad/s\nPhase Margin: 180.00 degrees at 628.32 rad/s\n</code></pre></p> <p></p>"},{"location":"control-design/04_bode_plot.html#stability-analysis","title":"Stability Analysis","text":""},{"location":"control-design/04_bode_plot.html#phase-and-gain-margins","title":"Phase and Gain Margins","text":"<p>Important stability metrics from Bode plots:</p> <pre><code># Calculate stability margins\ngm, pm, wg, wp = control.margin(G)\nprint(f\"Gain Margin: {gm} dB at {wg} rad/s\")\nprint(f\"Phase Margin: {pm} degrees at {wp} rad/s\")\n</code></pre> <p>For our band-pass filter: - Gain Margin: Infinite (system never crosses -180\u00b0 phase) - Phase Margin: 180\u00b0 at 628.32 rad/s - The system is stable for all positive gains</p>"},{"location":"control-design/04_bode_plot.html#compensator-design","title":"Compensator Design","text":""},{"location":"control-design/04_bode_plot.html#lead-compensator","title":"Lead Compensator","text":"<p>Improves phase margin and bandwidth:</p> <pre><code># Design lead compensator\nalpha = 10\nT = 1\nC = control.TransferFunction([T, 1], [T/alpha, 1])\n\n# Combined system\nGC = control.series(G, C)\n\n# Compare original and compensated systems\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, label='Original')\ncontrol.bode_plot(GC, label='Compensated')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"control-design/04_bode_plot.html#exercises","title":"Exercises","text":"<ol> <li>Create Bode plots for different first-order systems and analyze how the time constant affects the frequency response.</li> <li>Design a notch filter and analyze its frequency response.</li> <li>Compare the frequency responses of different types of compensators (lead, lag, lead-lag).</li> <li>Use Bode plots to design a controller that meets specific gain and phase margin requirements.</li> </ol>"}]}