{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"\ud83c\udfae Python for Control Systems","text":"<p>Welcome to Python4Control - your comprehensive guide to mastering control systems with Python! \ud83d\ude80</p>"},{"location":"index.html#overview","title":"Overview","text":"<p>This documentation provides a structured approach to learning control systems using Python, perfect for students, engineers, and hobbyists. Our tutorials combine theoretical concepts with practical implementations, making complex control theory accessible and applicable.</p>"},{"location":"index.html#available-tutorials","title":"\ud83d\udcda Available Tutorials","text":"<ul> <li> <p> Introduction to Control Systems</p> <p>Learn the fundamentals of control systems and Python implementation.</p> <p> Go to tutorial</p> </li> <li> <p> System Responses</p> <p>Learn about time and frequency domain responses of control systems.</p> <p> Go to tutorial</p> </li> <li> <p> Root Locus Analysis</p> <p>Master root locus techniques for control system analysis and design.</p> <p> Go to tutorial</p> </li> <li> <p> Bode Plot Analysis</p> <p>Learn frequency response analysis using Bode plots.</p> <p> Go to tutorial</p> </li> </ul>"},{"location":"index.html#what-youll-learn","title":"\ud83c\udfaf What You'll Learn","text":"<ul> <li> <p> System Analysis</p> <ul> <li>Transfer function manipulation</li> <li>State-space representations</li> <li>System response analysis</li> </ul> </li> <li> <p> Controller Design</p> <ul> <li>PID controller tuning</li> <li>State feedback control</li> <li>Observer design</li> </ul> </li> <li> <p> Visualization</p> <ul> <li>Time-domain responses</li> <li>Frequency responses</li> <li>Root locus plots</li> </ul> </li> <li> <p> Applications</p> <ul> <li>Real-world examples</li> <li>Practical implementations</li> <li>Case studies</li> </ul> </li> </ul>"},{"location":"index.html#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li> <p> Installation</p> <pre><code>git clone https://github.com/Hmustf/python4control.git\ncd python4control\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre> </li> <li> <p> Prerequisites</p> <ul> <li>Python 3.8+</li> <li>Basic control theory knowledge</li> <li>Familiarity with Python programming</li> </ul> </li> </ul>"},{"location":"index.html#useful-resources","title":"\ud83d\udd17 Useful Resources","text":"<ul> <li> <p> Libraries</p> <ul> <li>Python Control Systems Library</li> <li>NumPy Documentation</li> <li>Matplotlib Documentation</li> </ul> </li> <li> <p> Support</p> <ul> <li>GitHub Repository</li> <li>Report Issues</li> <li>Contributing Guidelines</li> </ul> </li> </ul>"},{"location":"index.html#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Whether it's adding new tutorials, improving existing examples, fixing bugs, or enhancing documentation, your help is appreciated. Check our Contributing Guidelines to get started. </p>"},{"location":"control-design/01_intro.html","title":"Control System Design with Python","text":""},{"location":"control-design/01_intro.html#introduction-to-control-systems-engineering","title":"Introduction to Control Systems Engineering","text":"<p>Control systems engineering is a crucial field that deals with the analysis and design of systems that maintain desired behaviors through feedback mechanisms. Python provides powerful tools for control system analysis and design.</p> <p>Key Python Libraries</p> <p>The following libraries are essential for control systems engineering:</p> <ul> <li><code>numpy</code> - Numerical computations<ul> <li>Efficient array operations</li> <li>Linear algebra functions</li> <li>Mathematical functions</li> </ul> </li> <li><code>control</code> - Control systems analysis<ul> <li>Transfer function creation and manipulation</li> <li>System analysis tools</li> <li>Control design methods</li> </ul> </li> <li><code>matplotlib</code> - Data visualization<ul> <li>2D and 3D plotting</li> <li>Multiple plot types</li> <li>Customizable visualizations</li> </ul> </li> <li><code>sympy</code> - Symbolic mathematics<ul> <li>Symbolic calculations</li> <li>Equation solving</li> <li>Laplace transforms</li> </ul> </li> <li><code>scipy</code> - Scientific computing<ul> <li>Differential equation solvers</li> <li>Optimization tools</li> <li>Signal processing functions</li> </ul> </li> </ul>"},{"location":"control-design/01_intro.html#python-fundamentals-for-control-systems","title":"Python Fundamentals for Control Systems","text":""},{"location":"control-design/01_intro.html#basic-python-concepts","title":"Basic Python Concepts","text":"<p>Python Syntax Overview</p> <p>Python's clean and readable syntax makes it ideal for engineering applications:</p> <pre><code># Basic variable assignments\nx = 123.3\ntext = \"Some text\"\nflag = True\nprint(f\"x = {x}, text = {text}, flag = {flag}\")\n\n# Lists (similar to arrays in other languages)\nx = [1, 2, 3, 4]\nprint(\"List x:\", x)\n</code></pre> <p>Output: <pre><code>x = 123.3, text = Some text, flag = True\nList x: [1, 2, 3, 4]\n</code></pre></p>"},{"location":"control-design/01_intro.html#numpy-for-numerical-computations","title":"NumPy for Numerical Computations","text":"<p>NumPy Arrays and Operations</p> <p>NumPy provides efficient array operations essential for control systems:</p> <pre><code>import numpy as np\n\n# Creating arrays\nx = np.array([1, 2, 3, 4])\nprint(\"NumPy array x:\", x)\n\n# Arrays of zeros and ones\nx = np.zeros(4)\ny = np.ones((2, 2))\nprint(\"Array of zeros:\", x)\nprint(\"2x2 array of ones:\\n\", y)\n\n# Array operations\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nprint(\"\\nArray operations:\")\nprint(\"a + b =\", a + b)\nprint(\"a * b =\", a * b)\nprint(\"a dot b =\", np.dot(a, b))\n</code></pre> <p>Output: <pre><code>NumPy array x: [1 2 3 4]\nArray of zeros: [0. 0. 0. 0.]\n2x2 array of ones:\n [[1. 1.]\n  [1. 1.]]\n\nArray operations:\na + b = [5 7 9]\na * b = [ 4 10 18]\na dot b = 32\n</code></pre></p>"},{"location":"control-design/01_intro.html#symbolic-mathematics-with-sympy","title":"Symbolic Mathematics with SymPy","text":"<p>Let's start with basic symbolic operations using a quadratic expression:</p> <p>Consider the quadratic expression:</p> \\[ f(x) = x^2 + 2x + 1 \\] <p>In standard form:</p> \\[ ax^2 + bx + c \\text{ where } a=1, b=2, c=1 \\] <p>Complete square form:</p> \\[ (x + 1)^2 \\] <p>Root:</p> \\[ x = -1 \\text{ (single root)} \\] <p>Basic Symbolic Operations</p> <pre><code>import sympy as sp\n\n# Define symbolic variable\nx = sp.Symbol('x')\n\n# Create and manipulate expressions\nexpr = x**2 + 2*x + 1\nprint(\"Original expression:\", expr)\n\n# Solve equation\neq = sp.Eq(expr, 0)\nsolution = sp.solve(eq, x)\nprint(\"\\nSolving x^2 + 2x + 1 = 0:\")\nprint(\"x =\", solution)\n</code></pre> <p>Output: <pre><code>Original expression: x**2 + 2*x + 1\n\nSolving x^2 + 2x + 1 = 0:\nx = [-1]\n</code></pre></p> <p>For the function:</p> \\[ f(x) = x^2 + 2x + 1 \\] <p>The derivative is:</p> \\[ \\frac{d}{dx}f(x) = 2x + 2 \\] <p>The integral is:</p> \\[ \\int f(x)dx = \\frac{x^3}{3} + x^2 + x + C \\] <p>Calculus Operations</p> <pre><code># Perform calculus operations\nderivative = sp.diff(expr, x)\nintegral = sp.integrate(expr, x)\n\nprint(\"Derivative:\", derivative)\nprint(\"Integral:\", integral)\n</code></pre> <p>Output: <pre><code>Derivative: 2*x + 2\nIntegral: x**3/3 + x**2 + x\n</code></pre></p> <p>Consider the time function:</p> \\[ f(t) = t^2e^{-t} \\] <p>The Laplace transform is:</p> \\[ \\mathcal{L}\\{t^2e^{-t}\\} = \\frac{2}{(s+1)^3} \\] <p>Laplace Transforms</p> <pre><code># Define time and complex frequency variables\nt = sp.Symbol('t')\ns = sp.Symbol('s')\n\n# Define time function and compute Laplace transform\nf_t = t**2 * sp.exp(-t)\nF_s = sp.laplace_transform(f_t, t, s)\n\nprint(\"Time function:\", f_t)\nprint(\"Laplace transform:\", F_s[0])\n</code></pre> <p>Output: <pre><code>Time function: t**2*exp(-t)\nLaplace transform: 2/(s + 1)**3\n</code></pre></p> <p>Consider the matrix:</p> \\[ M = \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{bmatrix} \\] <p>Properties:</p> <ol> <li>Determinant:</li> </ol> \\[ det(M) = (1 \\cdot 4) - (2 \\cdot 3) = -2 \\] <ol> <li>Inverse:</li> </ol> <p>First, compute the adjugate matrix divided by determinant:</p> \\[ M^{-1} = \\frac{1}{det(M)}\\begin{bmatrix} 4 &amp; -2 \\\\ -3 &amp; 1 \\end{bmatrix} \\] <p>Which simplifies to:</p> \\[ M^{-1} = \\begin{bmatrix} -2 &amp; 1 \\\\ \\frac{3}{2} &amp; -\\frac{1}{2} \\end{bmatrix} \\] <p>Matrix Operations</p> <pre><code># Create and manipulate matrices\nM = sp.Matrix([[1, 2], [3, 4]])\n\nprint(\"Matrix M:\")\nprint(M)\nprint(\"\\nDeterminant:\", M.det())\nprint(\"\\nInverse:\")\nprint(M.inv())\n</code></pre> <p>Output: <pre><code>Matrix M:\nMatrix([[1, 2], [3, 4]])\n\nDeterminant: -2\n\nInverse:\nMatrix([[-2, 1], [3/2, -1/2]])\n</code></pre></p>"},{"location":"control-design/01_intro.html#differential-equations-with-scipy","title":"Differential Equations with SciPy","text":"<p>Control systems often involve differential equations. Here's how to solve them:</p> <p>Consider the first-order differential equation:</p> \\[ \\frac{dy}{dt} = -y \\] <p>With initial condition:</p> \\[ y(0) = 1 \\] <p>The analytical solution is:</p> \\[ y(t) = e^{-t} \\] <p>Solving ODEs</p> <pre><code>import numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\n\n# Define the differential equation dy/dt = -y\ndef model(y, t):\n    return -y\n\n# Time points and initial condition\nt = np.linspace(0, 5, 100)\ny0 = 1\n\n# Solve ODE\nsolution = odeint(model, y0, t)\n\n# Plot results\nplt.figure(figsize=(10, 6))\nplt.plot(t, solution, 'b-', label='y(t)')\nplt.plot(t, np.exp(-t), 'r--', label='Analytical: e^(-t)')\nplt.grid(True)\nplt.xlabel('Time')\nplt.ylabel('y(t)')\nplt.title('Solution of dy/dt = -y')\nplt.legend()\nplt.show()\n\n# Print solution values\nprint(\"Solution values at t = [0, 1, 2, 3, 4, 5]:\")\nt_points = [0, 1, 2, 3, 4, 5]\ny_points = np.interp(t_points, t, solution.flatten())\nfor t_val, y_val in zip(t_points, y_points):\n    print(f\"t = {t_val:.1f}, y = {y_val:.4f}\")\n</code></pre> <p>Output: <pre><code>Solution values at t = [0, 1, 2, 3, 4, 5]:\nt = 0.0, y = 1.0000\nt = 1.0, y = 0.3680\nt = 2.0, y = 0.1354\nt = 3.0, y = 0.0498\nt = 4.0, y = 0.0183\nt = 5.0, y = 0.0067\n</code></pre></p> <p></p>"},{"location":"control-design/01_intro.html#advanced-plotting-techniques","title":"Advanced Plotting Techniques","text":""},{"location":"control-design/01_intro.html#multiple-plots-and-subplots","title":"Multiple Plots and Subplots","text":"<p>Creating Complex Plots</p> <p>Control system analysis often requires multiple plots:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate data\nt = np.linspace(0, 10, 1000)\nf1 = np.sin(t)\nf2 = np.cos(t)\nf3 = np.exp(-0.1*t)*np.sin(t)\n\n# Create figure with subplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\n\n# First subplot: Multiple functions\nax1.plot(t, f1, 'b-', label='sin(t)')\nax1.plot(t, f2, 'r--', label='cos(t)')\nax1.grid(True)\nax1.set_xlabel('Time')\nax1.set_ylabel('Amplitude')\nax1.set_title('Trigonometric Functions')\nax1.legend()\n</code></pre> <p></p>"},{"location":"control-design/01_intro.html#data-visualization-with-scatter-plots","title":"Data Visualization with Scatter Plots","text":"<p>Scatter Plot with Color Mapping</p> <p>Visualize relationships between variables:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate random data\nnp.random.seed(42)\nx = np.random.normal(0, 1, 1000)\ny = np.random.normal(0, 1, 1000)\nz = np.sqrt(x**2 + y**2)\n\n# Create scatter plot\nplt.figure(figsize=(10, 8))\nscatter = plt.scatter(x, y, c=z, cmap='viridis', \n                     s=50, alpha=0.5)\nplt.colorbar(scatter, label='Distance from origin')\nplt.grid(True)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Scatter Plot with Color Mapping')\nplt.axis('equal')\nplt.show()\n</code></pre> <p></p>"},{"location":"control-design/01_intro.html#control-systems-with-python-control","title":"Control Systems with Python Control","text":""},{"location":"control-design/01_intro.html#transfer-functions-and-step-response","title":"Transfer Functions and Step Response","text":"<p>Basic Control System Analysis</p> <p>The <code>control</code> library provides essential tools:</p> <p>Consider the transfer function:</p> \\[ G(s) = \\frac{s + 2}{s^2 + 2s + 1} \\] <pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a transfer function G(s) = (s + 2)/(s^2 + 2s + 1)\ns = control.TransferFunction.s\nG = control.TransferFunction([1, 2], [1, 2, 1])\n\n# Generate and plot step response\nt, y = control.step_response(G)\nplt.figure(figsize=(10, 6))\nplt.plot(t, y, linewidth=2)\nplt.grid(True)\nplt.title('Step Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre> <p></p>"},{"location":"control-design/01_intro.html#multiple-system-responses","title":"Multiple System Responses","text":"<p>Comparing Different Systems</p> <p>Compare responses of different transfer functions:</p> \\[ \\text{For different values of } a\\text{, consider: } G(s) = \\frac{a}{s + a} \\] <pre><code># Create multiple transfer functions\nplt.figure(figsize=(10, 6))\nt = np.linspace(0, 5, 500)\n\nfor a in range(1, 6):\n    G = control.TransferFunction([a], [1, a])\n    t, y = control.step_response(G, t)\n    plt.plot(t, y, linewidth=2, label=f'a={a}')\n\nplt.grid(True)\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.title('Step Responses for Different Systems')\nplt.legend(loc='lower right')\nplt.show()\n</code></pre> <p></p> <p>Best Practices</p> <p>When working with control systems in Python:</p> <ol> <li>Always use descriptive variable names</li> <li>Include proper axis labels and titles</li> <li>Add legends when plotting multiple curves</li> <li>Use appropriate time scales for system responses</li> <li>Document transfer functions and system parameters</li> <li>Include grid lines for better readability</li> <li>Save high-resolution figures for documentation</li> </ol>"},{"location":"control-design/02_system_responses.html","title":"System Responses in Control Systems","text":"<p>This tutorial covers the analysis of system responses in both time and frequency domains.</p>"},{"location":"control-design/02_system_responses.html#time-domain-responses","title":"Time Domain Responses","text":""},{"location":"control-design/02_system_responses.html#step-response","title":"Step Response","text":"<p>The step response is one of the most fundamental ways to analyze a control system's behavior.</p> <pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a transfer function G(s) = 1/(s + 1)\nG = control.TransferFunction([1], [1, 1])\n\n# Generate step response\nt, y = control.step_response(G)\n\nplt.figure()\nplt.plot(t, y)\nplt.grid(True)\nplt.title('Step Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(s + 1)\nFinal Value: 1.00\nRise Time: 2.30 seconds\nSettling Time: 3.91 seconds\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#impulse-response","title":"Impulse Response","text":"<p>The impulse response shows how the system responds to a brief input pulse.</p> <pre><code># Generate impulse response\nt, y = control.impulse_response(G)\n\nplt.figure()\nplt.plot(t, y)\nplt.grid(True)\nplt.title('Impulse Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(s + 1)\nPeak Value: 1.00\nPeak Time: 0.00 seconds\nSettling Time: 3.98 seconds\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#ramp-response","title":"Ramp Response","text":"<p>The ramp response shows how the system follows a continuously increasing input.</p> <pre><code># Create time vector\nt = np.linspace(0, 10, 1000)\nu = t\nt_out, y = control.forced_response(G, T=t, U=u)\n\nplt.figure()\nplt.plot(t_out, u, '--', label='Input')\nplt.plot(t_out, y, label='Output')\nplt.grid(True)\nplt.title('Ramp Response')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.legend()\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(s + 1)\nSteady-State Error Rate: 1.00\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#response-characteristics","title":"Response Characteristics","text":""},{"location":"control-design/02_system_responses.html#rise-time","title":"Rise Time","text":"<p>The time required for the system output to rise from 10% to 90% of its final value.</p> <p>Rise Time Formula</p> <p>For any system:</p> \\[t_r = t_{90\\%} - t_{10\\%}\\] <p>where: - \\(t_r\\) is the rise time - \\(t_{90\\%}\\) is the time when output reaches 90% of final value - \\(t_{10\\%}\\) is the time when output reaches 10% of final value</p> <p>First-Order System Rise Time</p> <p>For a first-order system with transfer function \\(G(s) = \\frac{1}{\\tau s + 1}\\):</p> \\[t_r = 2.2\\tau\\]"},{"location":"control-design/02_system_responses.html#settling-time","title":"Settling Time","text":"<p>The time required for the system to settle within \u00b12% of its final value.</p> <p>Settling Time Formulas</p> <p>For a second-order system:</p> \\[t_s = \\frac{4}{\\zeta\\omega_n}\\] <p>where: - \\(t_s\\) is the settling time - \\(\\zeta\\) is the damping ratio - \\(\\omega_n\\) is the natural frequency</p> <p>For a first-order system:</p> \\[t_s = 4\\tau\\]"},{"location":"control-design/02_system_responses.html#overshoot","title":"Overshoot","text":"<p>The maximum peak value of the response curve measured from the desired response of the system.</p> <p>Important: Second-Order System Overshoot</p> <p>For a second-order system:</p> \\[M_p = e^{-\\pi\\zeta/\\sqrt{1-\\zeta^2}} \\times 100\\%\\] <p>where: - \\(M_p\\) is the percentage overshoot - \\(\\zeta\\) is the damping ratio</p> <p>The peak time (time to reach maximum overshoot) is:</p> \\[t_p = \\frac{\\pi}{\\omega_n\\sqrt{1-\\zeta^2}}\\]"},{"location":"control-design/02_system_responses.html#steady-state-error","title":"Steady-State Error","text":"<p>The difference between the desired output and the actual output as time approaches infinity.</p>"},{"location":"control-design/02_system_responses.html#definition-and-basic-formulas","title":"Definition and Basic Formulas","text":"<p>Steady-State Error Definition</p> <p>For any input \\(r(t)\\) and output \\(y(t)\\), the steady-state error is defined as:</p> \\[e_{ss} = \\lim_{t \\to \\infty} [r(t) - y(t)] = \\lim_{s \\to 0} [sR(s) - sY(s)]\\] <p>For a unity feedback system with forward transfer function \\(G(s)\\):</p> \\[e_{ss} = \\lim_{s \\to 0} \\frac{R(s)}{1 + G(s)}\\]"},{"location":"control-design/02_system_responses.html#system-type-and-error-constants","title":"System Type and Error Constants","text":"<p>The system type N is determined by the number of free integrators in the open-loop transfer function \\(G(s)\\).</p> System Type \\(G(s)\\) Form Example Type 0 \\(\\frac{K}{(s + p_1)(s + p_2)...}\\) \\(\\frac{K}{s + 1}\\) Type 1 \\(\\frac{K}{s(s + p_1)(s + p_2)...}\\) \\(\\frac{K}{s(s + 1)}\\) Type 2 \\(\\frac{K}{s^2(s + p_1)(s + p_2)...}\\) \\(\\frac{K}{s^2(s + 1)}\\)"},{"location":"control-design/02_system_responses.html#error-constants-and-their-relationships","title":"Error Constants and Their Relationships","text":"Error Constant Formula Description Position (\\(K_p\\)) \\(\\lim_{s \\to 0} G(s)\\) For step input Velocity (\\(K_v\\)) \\(\\lim_{s \\to 0} sG(s)\\) For ramp input Acceleration (\\(K_a\\)) \\(\\lim_{s \\to 0} s^2G(s)\\) For parabolic input"},{"location":"control-design/02_system_responses.html#steady-state-error-for-different-input-types","title":"Steady-State Error for Different Input Types","text":"Input Type Input Function Error Formula Type 0 Type 1 Type 2 Step \\(\\frac{1}{s}\\) \\(\\frac{1}{1 + K_p}\\) Finite Zero Zero Ramp \\(\\frac{1}{s^2}\\) \\(\\frac{1}{K_v}\\) Infinite Finite Zero Parabolic \\(\\frac{1}{s^3}\\) \\(\\frac{1}{K_a}\\) Infinite Infinite Finite"},{"location":"control-design/02_system_responses.html#example-calculations","title":"Example Calculations","text":"<p>Practice Example 1: First-Order System</p> <p>Consider a first-order system \\(G(s) = \\frac{1}{s + 1}\\) (Type 0):</p> <p>Step Input Analysis </p> <ol> <li> <p>Calculate Position Error Constant:      <p>\\(K_p = G(0) = 1\\)</p> <li> <p>Calculate Steady-State Error:      <p>\\(e_{ss} = \\frac{1}{1 + K_p} = \\frac{1}{1 + 1} = 0\\)</p> <p>Ramp Input Analysis </p> <ol> <li> <p>Calculate Velocity Error Constant:      <p>\\(K_v = \\lim\\limits_{s \\to 0} sG(s) = 0\\)</p> <li> <p>Calculate Steady-State Error:      <p>\\(e_{ss} = \\frac{1}{K_v} = \\infty\\) (constant error rate)</p> <p>Practice Example 2: Type 1 System</p> <p>Consider a Type 1 system \\(G(s) = \\frac{K}{s(s + 1)}\\):</p> <p>Step Input Analysis </p> <ol> <li> <p>Calculate Position Error Constant:      <p>\\(K_p = \\lim\\limits_{s \\to 0} G(s) = \\infty\\)</p> <li> <p>Calculate Steady-State Error:      <p>\\(e_{ss} = \\frac{1}{1 + K_p} = 0\\)</p> <p>Ramp Input Analysis </p> <ol> <li> <p>Calculate Velocity Error Constant:      <p>\\(K_v = \\lim\\limits_{s \\to 0} sG(s) = K\\)</p> <li> <p>Calculate Steady-State Error:      <p>\\(e_{ss} = \\frac{1}{K_v} = \\frac{1}{K}\\)</p>"},{"location":"control-design/02_system_responses.html#summary-of-second-order-system-performance-characteristics","title":"Summary of Second-Order System Performance Characteristics","text":"<p>The following figure summarizes the relationships between system parameters and performance characteristics:</p> <p></p>"},{"location":"control-design/02_system_responses.html#example-analyzing-second-order-system","title":"Example: Analyzing Second-Order System","text":"<pre><code>import matplotlib.pyplot as plt\nimport control\nimport numpy as np\nimport seaborn as sns\n\n# Set the style to a modern, clean theme\nplt.style.use('seaborn-v0_8')\nsns.set_style(\"whitegrid\", {'grid.linestyle': ':'})\nplt.rcParams['font.family'] = 'sans-serif'\nplt.rcParams['font.sans-serif'] = ['Arial']\n\n# Define system parameters\nNATURAL_FREQUENCY = 1.0  # Natural frequency (wn)\nDAMPING_RATIO = 0.5      # Damping ratio (zeta)\n\n# Create a second-order transfer function\nnumerator = [NATURAL_FREQUENCY**2]\ndenominator = [1, 2 * DAMPING_RATIO * NATURAL_FREQUENCY, NATURAL_FREQUENCY**2]\nG = control.TransferFunction(numerator, denominator)\n\n# Get step response\nt, y = control.step_response(G)\n\n# Get step response characteristics\ninfo = control.step_info(G)\n\n# Extract key values\nrise_time = info['RiseTime']\npeak_time = info['PeakTime']\npeak_value = info['Peak']\nsettling_time = info['SettlingTime']\novershoot = info['Overshoot']\n\n# Function to find the nearest index in the time array\ndef find_nearest(array, value):\n    idx = (np.abs(array - value)).argmin()\n    return idx\n\n# Create figure with a specific background color\nplt.figure(figsize=(14, 8))  # Restored to original larger size\nax = plt.gca()\nax.set_facecolor('#ffffff')\nplt.gcf().set_facecolor('#ffffff')\n\n# Custom color palette\nmain_color = '#2E86AB'  # Blue\nsteady_state_color = '#D64933'  # Red\nannotation_color = '#1B1B1E'  # Dark gray\ngrid_color = '#E5E5E5'  # Light gray\novershoot_color = '#FF6B6B'  # Coral for overshoot arrow\nsettling_color = '#6C757D'  # Gray for settling bounds\n\n# Plot step response curve with gradient\nline, = plt.plot(t, y, label='Step Response', linewidth=3, color=main_color)\n\n# Plot steady-state line\nplt.axhline(y=1, color=steady_state_color, linestyle='--', label='Steady-State Value', linewidth=2, alpha=0.8)\n\n# Add \u00b12% settling time bounds\nplt.axhline(y=1.02, color=settling_color, linestyle=':', label='\u00b12% Bounds', linewidth=1.5, alpha=0.6)\nplt.axhline(y=0.98, color=settling_color, linestyle=':', linewidth=1.5, alpha=0.6)\n\n# Create shaded regions for better visualization\nplt.fill_between(t, y, 1, where=(y &gt; 1), color=main_color, alpha=0.15, interpolate=True, label='Error')\nplt.fill_between(t, y, 1, where=(y &lt; 1), color=main_color, alpha=0.1, interpolate=True)\n\n# Plot vertical lines with gradient alpha\nfor time, label in [(rise_time, 'Rise Time'), (peak_time, 'Peak Time'), (settling_time, 'Settling Time')]:\n    plt.vlines(time, 0, y[find_nearest(t, time)], colors=annotation_color, linestyles=':', alpha=0.3)\n\n# Create fancy boxes for annotations with improved styling\ndef create_annotation_box(text):\n    return dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.95, \n               edgecolor=annotation_color, linewidth=1)\n\n# Add overshoot double-headed arrow\nplt.annotate('', xy=(peak_time, peak_value), \n            xytext=(peak_time, 1),\n            arrowprops=dict(arrowstyle='&lt;-&gt;', color=overshoot_color, \n                          linewidth=2, shrinkA=0, shrinkB=0))\n\n# Add overshoot label centered on the double-headed arrow\nplt.annotate(f'Overshoot\\n{overshoot:.1f}%', \n            xy=(peak_time, (peak_value + 1)/2),  # Middle point of the arrow\n            xytext=(peak_time, (peak_value + 1)/2),  # Exactly on the arrow\n            fontsize=9,\n            color=annotation_color,\n            bbox=create_annotation_box(''),\n            ha='center',  # Center horizontally\n            va='center')  # Center vertically\n\nplt.annotate(f'Rise Time\\n{rise_time:.2f} s', \n             xy=(rise_time, y[find_nearest(t, rise_time)]),\n             xytext=(rise_time + 1, y[find_nearest(t, rise_time)] - 0.2),\n             fontsize=11,\n             color=annotation_color,\n             bbox=create_annotation_box(''),\n             arrowprops=dict(arrowstyle='fancy', color=annotation_color, alpha=0.6),\n             ha='center')\n\nplt.annotate(f'Peak Time\\n{peak_time:.2f} s', \n             xy=(peak_time, peak_value),\n             xytext=(peak_time + 0.5, peak_value + 0.1),\n             fontsize=11,\n             color=annotation_color,\n             bbox=create_annotation_box(''),\n             arrowprops=dict(arrowstyle='fancy', color=annotation_color, alpha=0.6),\n             ha='center')\n\n# Add settling time annotation with bounds info\nplt.annotate(f'Settling Time\\n{settling_time:.2f} s\\n\u00b12% Bounds', \n             xy=(settling_time, 1),\n             xytext=(settling_time + 1.5, 1.1),  # Changed y position from 0.7 to 0.8\n             fontsize=11,\n             color=annotation_color,\n             bbox=create_annotation_box(''),\n             arrowprops=dict(arrowstyle='fancy', color=annotation_color, alpha=0.6),\n             ha='center')\n\n# Add system parameters annotation\nplt.text(0.02, 0.98, f'System Parameters:\\n\u03c9n = {NATURAL_FREQUENCY} rad/s\\n\u03b6 = {DAMPING_RATIO}',\n         transform=ax.transAxes,\n         bbox=dict(facecolor='white', alpha=0.95, edgecolor=annotation_color, \n                  boxstyle='round,pad=0.5', linewidth=1),\n         fontsize=11,\n         color=annotation_color,\n         verticalalignment='top')\n\n# Enhance grid with custom styling\nax.grid(True, which='major', color=grid_color, linewidth=1.2, alpha=0.8)\nax.grid(True, which='minor', color=grid_color, linewidth=0.8, alpha=0.5)\n\n# Set axis limits with padding to ensure annotations are visible\nplt.xlim(-0.2, max(t) + 0.5)\nplt.ylim(-0.1, max(y) + 0.3)\n\n# Title and labels with enhanced styling\nplt.title('Second-Order System Step Response', fontsize=16, pad=20, \n          color=annotation_color, fontweight='bold')\nplt.xlabel('Time (s)', fontsize=12, labelpad=10, color=annotation_color)\nplt.ylabel('Amplitude', fontsize=12, labelpad=10, color=annotation_color)\n\n# Customize ticks\nplt.xticks(fontsize=10, color=annotation_color)\nplt.yticks(fontsize=10, color=annotation_color)\n\n# Enhanced legend with new styling\nplt.legend(loc='upper right', fontsize=11, fancybox=True, \n          framealpha=0.95, edgecolor=annotation_color)\n\n# Adjust layout and save with high DPI\nplt.tight_layout()\nplt.savefig('docs/images/examples/second_order_response.png', dpi=300, bbox_inches='tight',  # Restored to original DPI\n            facecolor='white', edgecolor='none')\n\n# Show plot\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = \u03c9n\u00b2/(s\u00b2 + 2\u03b6\u03c9n\u00b7s + \u03c9n\u00b2)\nNatural Frequency (\u03c9n): 1.00 rad/s\nDamping Ratio (\u03b6): 0.50\nRise Time: 1.67 seconds\nPeak Time: 3.63 seconds\nOvershoot: 16.3%\nSettling Time: 8.09 seconds\n</code></pre></p> <p></p>"},{"location":"control-design/02_system_responses.html#exercises","title":"Exercises","text":"<ol> <li>Create a transfer function for a second-order system with different natural frequencies and damping ratios. Compare their step responses.</li> <li>Analyze how the damping ratio affects the overshoot and settling time of a second-order system.</li> <li>Design a system to meet specific time-domain specifications (rise time, settling time, overshoot).</li> </ol>"},{"location":"control-design/03_root_locus.html","title":"Root Locus Analysis","text":"<p>The root locus is a graphical method for analyzing how the poles of a closed-loop system change as a system parameter (usually the gain) varies.</p>"},{"location":"control-design/03_root_locus.html#understanding-root-locus","title":"Understanding Root Locus","text":"<p>The root locus shows the paths that the poles of the closed-loop system follow as the gain K varies from 0 to \u221e. For a system with forward transfer function G(s) and unity feedback:</p> \\[ T(s) = \\frac{KG(s)}{1 + KG(s)} \\]"},{"location":"control-design/03_root_locus.html#basic-rules-for-sketching-root-locus","title":"Basic Rules for Sketching Root Locus","text":"<ol> <li>The root locus starts at the open-loop poles (K = 0)</li> <li>The root locus ends at the open-loop zeros (K = \u221e)</li> <li>The number of branches equals the number of open-loop poles</li> <li>Branches approach asymptotes at high gains</li> <li>The root locus is symmetric about the real axis</li> </ol>"},{"location":"control-design/03_root_locus.html#example-1-simple-second-order-system","title":"Example 1: Simple Second-Order System","text":"<pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create transfer function G(s) = 1/(s(s + 2))\nnum = [1]\nden = [1, 2, 0]  # s^2 + 2s\nG = control.TransferFunction(num, den)\n\n# Generate root locus\nplt.figure(figsize=(10, 8))\nrlist, klist = control.root_locus(G, plot=True)\nplt.title('Root Locus: G(s) = 1/s(s + 2)')\nplt.grid(True)\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/s(s + 2)\nOpen-Loop Poles: [-2.+0.j  0.+0.j]\nCritical Gain (K) at Imaginary Axis: 0.00\n</code></pre></p> <p></p>"},{"location":"control-design/03_root_locus.html#example-2-system-with-multiple-poles","title":"Example 2: System with Multiple Poles","text":"<pre><code># Create transfer function G(s) = 1/((s+1)(s+2)(s+3))\nG = control.TransferFunction([1], [1, 6, 11, 6])\n\n# Generate root locus\nplt.figure(figsize=(10, 8))\nrlist, klist = control.root_locus(G, plot=True)\nplt.title('Root Locus: G(s) = 1/((s+1)(s+2)(s+3))')\nplt.grid(True)\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/((s+1)(s+2)(s+3))\nOpen-Loop Poles: [-3.+0.j -2.+0.j -1.+0.j]\n</code></pre></p> <p></p>"},{"location":"control-design/03_root_locus.html#analyzing-root-locus-features","title":"Analyzing Root Locus Features","text":""},{"location":"control-design/03_root_locus.html#break-away-points","title":"Break-Away Points","text":"<p>Points where branches of the root locus depart from the real axis.</p> <p>For our simple second-order system: - Break-away point occurs at s = -1 (where the branches split from the real axis) - This happens at a gain value of K = 1</p>"},{"location":"control-design/03_root_locus.html#crossing-points","title":"Crossing Points","text":"<p>Points where the root locus crosses the imaginary axis, indicating stability boundaries.</p> <p>For our simple second-order system: - The root locus crosses the imaginary axis at approximately \u00b1j1.4 - This occurs at a gain value of K \u2248 4.0</p>"},{"location":"control-design/03_root_locus.html#design-example-lead-compensator","title":"Design Example: Lead Compensator","text":"<pre><code># Design a lead compensator\nalpha = 10\nT = 1\nnum_c = [T, 1]\nden_c = [T/alpha, 1]\nC = control.TransferFunction(num_c, den_c)\n\n# Combined system\nGC = control.series(G, C)\n\n# Plot root locus of compensated system\nplt.figure(figsize=(10, 8))\ncontrol.root_locus(GC)\nplt.title('Root Locus with Lead Compensator')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"control-design/03_root_locus.html#stability-analysis-using-root-locus","title":"Stability Analysis Using Root Locus","text":""},{"location":"control-design/03_root_locus.html#gain-selection","title":"Gain Selection","text":"<p>The root locus helps in selecting appropriate gain values for stability:</p> <pre><code># Find gain for specific closed-loop poles\ndesired_poles = [-1 + 1j, -1 - 1j]\nK = control.root_locus_plot(G, plot=False)\n</code></pre>"},{"location":"control-design/03_root_locus.html#stability-margins","title":"Stability Margins","text":"<p>Analyzing stability margins from root locus:</p> <pre><code># Calculate gain and phase margins\ngm, pm, _, _ = control.margin(G)\nprint(f\"Gain Margin: {gm} dB\")\nprint(f\"Phase Margin: {pm} degrees\")\n</code></pre>"},{"location":"control-design/03_root_locus.html#exercises","title":"Exercises","text":"<ol> <li>Plot the root locus for a system with transfer function G(s) = K/(s\u00b2 + 2s + 2).</li> <li>Find the range of K for which the system is stable.</li> <li>Design a compensator to achieve specific closed-loop pole locations.</li> <li>Analyze how zeros affect the root locus shape and system stability.</li> </ol>"},{"location":"control-design/04_bode_plot.html","title":"Bode Plot Analysis","text":"<p>Bode plots are frequency response diagrams that show the magnitude and phase of a system's frequency response on separate logarithmic plots.</p>"},{"location":"control-design/04_bode_plot.html#understanding-bode-plots","title":"Understanding Bode Plots","text":"<p>A Bode plot consists of two graphs: 1. Magnitude plot (in decibels) vs. frequency 2. Phase plot (in degrees) vs. frequency</p>"},{"location":"control-design/04_bode_plot.html#basic-elements-of-bode-plots","title":"Basic Elements of Bode Plots","text":""},{"location":"control-design/04_bode_plot.html#first-order-systems","title":"First-Order Systems","text":"<p>For a first-order system G(s) = 1/(\u03c4s + 1):</p> <pre><code>import control\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create first-order system\ntau = 1.0  # Time constant\nG = control.TransferFunction([1], [tau, 1])\n\n# Generate Bode plot\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, dB=True)\nplt.suptitle('Bode Plot: First-Order System')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = 1/(\u03c4s + 1)\nTime Constant (\u03c4): 1.00\nCorner Frequency: 1.00 rad/s\nPhase at Corner Frequency: -0.8 degrees\n</code></pre></p> <p></p>"},{"location":"control-design/04_bode_plot.html#second-order-systems","title":"Second-Order Systems","text":"<p>For a second-order system G(s) = \u03c9n\u00b2/(s\u00b2 + 2\u03b6\u03c9n\u00b7s + \u03c9n\u00b2):</p> <pre><code># Create second-order system\nwn = 10.0  # Natural frequency\nzeta = 0.5  # Damping ratio\nnum = [wn**2]\nden = [1, 2*zeta*wn, wn**2]\nG = control.TransferFunction(num, den)\n\n# Generate Bode plot\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, dB=True)\nplt.suptitle('Bode Plot: Second-Order System')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = \u03c9n\u00b2/(s\u00b2 + 2\u03b6\u03c9n\u00b7s + \u03c9n\u00b2)\nNatural Frequency (\u03c9n): 10.00 rad/s\nDamping Ratio (\u03b6): 0.50\nResonance Peak: 1.15 dB\nResonance Frequency: 7.06 rad/s\n</code></pre></p> <p></p>"},{"location":"control-design/04_bode_plot.html#frequency-response-analysis","title":"Frequency Response Analysis","text":""},{"location":"control-design/04_bode_plot.html#bandwidth","title":"Bandwidth","text":"<p>The frequency at which the magnitude drops by -3dB:</p> <pre><code># Function to find bandwidth\ndef find_bandwidth(sys):\n    w = np.logspace(-2, 2, 1000)\n    mag, _, _ = control.bode(sys, w, plot=False)\n\n    # Find -3dB frequency\n    bandwidth_idx = np.where(mag &lt;= -3)[0][0]\n    return w[bandwidth_idx]\n</code></pre> <p>For our second-order system: - Bandwidth \u2248 10 rad/s (at the natural frequency) - The -3dB point occurs at approximately the natural frequency</p>"},{"location":"control-design/04_bode_plot.html#resonance-peak","title":"Resonance Peak","text":"<p>The maximum magnitude in the frequency response:</p> <pre><code># Function to find resonance peak\ndef find_resonance(sys):\n    w = np.logspace(-2, 2, 1000)\n    mag, _, _ = control.bode(sys, w, plot=False)\n\n    return np.max(mag), w[np.argmax(mag)]\n</code></pre> <p>For our second-order system with \u03b6 = 0.5: - Resonance Peak: 1.15 dB - Resonance Frequency: 7.06 rad/s</p>"},{"location":"control-design/04_bode_plot.html#example-band-pass-filter","title":"Example: Band-Pass Filter","text":"<pre><code># Define band-pass filter parameters\nf0 = 100  # Center frequency (Hz)\nQ = 10    # Quality factor\nw0 = 2 * np.pi * f0\n\n# Create transfer function\nnum = [w0/Q, 0]\nden = [1, w0/Q, w0**2]\nG = control.TransferFunction(num, den)\n\n# Generate Bode plot\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, dB=True)\nplt.suptitle('Bode Plot: Band-Pass Filter')\nplt.show()\n</code></pre> <p>Output: <pre><code>Transfer Function G(s) = (w0/Q\u00b7s)/(s\u00b2 + (w0/Q)s + w0\u00b2)\nCenter Frequency (f0): 100.00 Hz\nQuality Factor (Q): 10.00\nGain Margin: inf dB at nan rad/s\nPhase Margin: 180.00 degrees at 628.32 rad/s\n</code></pre></p> <p></p>"},{"location":"control-design/04_bode_plot.html#stability-analysis","title":"Stability Analysis","text":""},{"location":"control-design/04_bode_plot.html#phase-and-gain-margins","title":"Phase and Gain Margins","text":"<p>Important stability metrics from Bode plots:</p> <pre><code># Calculate stability margins\ngm, pm, wg, wp = control.margin(G)\nprint(f\"Gain Margin: {gm} dB at {wg} rad/s\")\nprint(f\"Phase Margin: {pm} degrees at {wp} rad/s\")\n</code></pre> <p>For our band-pass filter: - Gain Margin: Infinite (system never crosses -180\u00b0 phase) - Phase Margin: 180\u00b0 at 628.32 rad/s - The system is stable for all positive gains</p>"},{"location":"control-design/04_bode_plot.html#compensator-design","title":"Compensator Design","text":""},{"location":"control-design/04_bode_plot.html#lead-compensator","title":"Lead Compensator","text":"<p>Improves phase margin and bandwidth:</p> <pre><code># Design lead compensator\nalpha = 10\nT = 1\nC = control.TransferFunction([T, 1], [T/alpha, 1])\n\n# Combined system\nGC = control.series(G, C)\n\n# Compare original and compensated systems\nplt.figure(figsize=(10, 10))\ncontrol.bode_plot(G, label='Original')\ncontrol.bode_plot(GC, label='Compensated')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"control-design/04_bode_plot.html#exercises","title":"Exercises","text":"<ol> <li>Create Bode plots for different first-order systems and analyze how the time constant affects the frequency response.</li> <li>Design a notch filter and analyze its frequency response.</li> <li>Compare the frequency responses of different types of compensators (lead, lag, lead-lag).</li> <li>Use Bode plots to design a controller that meets specific gain and phase margin requirements.</li> </ol>"}]}